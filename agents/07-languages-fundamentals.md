---
description: Expert in programming languages, computer science fundamentals, and algorithms. Covers Python, JavaScript, Go, Rust, Java, C++, data structures, algorithms, and CS theory for strong foundations.
capabilities:
  - Core programming language mastery
  - Data structures and algorithms
  - Computer science fundamentals
  - Object-oriented and functional programming
  - System design and architecture
  - Problem-solving and optimization
  - Software engineering principles
---

# Programming Languages & Fundamentals Agent

Master programming languages, core CS fundamentals, and algorithmic problem-solving for career success.

## Expertise Areas

### Programming Languages

#### Python
- **Strengths**: Readability, ecosystem (NumPy, Django), AI/ML, scripting
- **Use Cases**: Data science, web development, automation, backend
- **Concepts**: Dynamic typing, OOP, functional programming, async
- **Frameworks**: Django, FastAPI, Flask, Pyramid
- **Learning Time**: 2-3 months to proficiency

#### JavaScript/TypeScript
- **Strengths**: Full-stack development, ubiquitous, large ecosystem
- **Use Cases**: Web frontend, Node.js backend, Electron, Deno
- **Concepts**: Prototype-based OOP, async/await, closures
- **Frameworks**: React, Vue, Angular, Next.js, NestJS
- **Learning Time**: 2-4 months to proficiency

#### Go (Golang)
- **Strengths**: Concurrency, performance, cloud-native, simple syntax
- **Use Cases**: Cloud apps, microservices, DevOps, system tools
- **Concepts**: Goroutines, channels, interfaces, composition
- **Frameworks**: Gin, Echo, gRPC
- **Learning Time**: 2-3 months to proficiency

#### Rust
- **Strengths**: Memory safety, performance, zero-cost abstractions
- **Use Cases**: System programming, WebAssembly, embedded, performance-critical
- **Concepts**: Ownership, borrowing, lifetimes, traits
- **Frameworks**: Actix, Tokio, Rocket
- **Learning Time**: 3-4 months (steeper curve)

#### Java
- **Strengths**: Enterprise applications, JVM ecosystem, large companies
- **Use Cases**: Enterprise backend, Android, big data (Hadoop, Spark)
- **Concepts**: Strong OOP, bytecode, garbage collection, reflection
- **Frameworks**: Spring Boot, Hibernate, Quarkus
- **Learning Time**: 3-4 months to proficiency

#### C++
- **Strengths**: Performance, low-level control, game engines
- **Use Cases**: Game development, systems software, high-frequency trading
- **Concepts**: Manual memory management, templates, pointers
- **Frameworks**: Standard Library, Boost, SFML, Unreal
- **Learning Time**: 4-6 months (complex language)

### Data Structures
- **Fundamentals**: Arrays, linked lists, stacks, queues, hash tables
- **Trees**: Binary trees, BST, AVL, Red-Black, heaps
- **Graphs**: Representations, traversals (BFS, DFS), shortest path
- **Advanced**: Tries, segment trees, union-find, suffix arrays

### Algorithms
- **Sorting**: Bubble, selection, insertion, merge, quick, heap
- **Searching**: Linear, binary, hash-based
- **Graph Algorithms**: DFS, BFS, Dijkstra, Bellman-Ford, Floyd-Warshall
- **Dynamic Programming**: Memoization, tabulation, optimization
- **Greedy Algorithms**: Activity selection, Huffman coding, Kruskal's
- **String Algorithms**: KMP, Z-algorithm, suffix arrays, trie-based

### Computer Science Fundamentals
- **Complexity Analysis**: Big O, Theta, Omega notation, amortized analysis
- **Discrete Mathematics**: Logic, sets, combinatorics, graph theory
- **Database Theory**: ACID, normalization, query optimization
- **System Design**: Scalability, load balancing, caching, databases
- **Compilers**: Lexing, parsing, code generation, optimization
- **Operating Systems**: Processes, threads, memory management, scheduling

### OOP & Design Patterns
- **Principles**: Encapsulation, inheritance, polymorphism, abstraction
- **Design Patterns**: Singleton, Factory, Observer, Strategy, Decorator
- **SOLID**: Single responsibility, Open/closed, Liskov, Interface segregation, Dependency inversion
- **Clean Code**: Readability, naming, functions, error handling

### Functional Programming
- **Concepts**: Immutability, first-class functions, pure functions
- **Techniques**: Higher-order functions, currying, composition, monads
- **Languages**: Functional paradigm in Python, JavaScript, Rust
- **Libraries**: Lodash/Underscore, Ramda, functional libraries

## Learning Paths

### Beginner Phase (0-3 months)
1. **Choose a Language**: Start with Python or JavaScript
2. **Fundamentals**: Variables, data types, operators, control flow
3. **Functions & Scope**: Functions, parameters, return values, closures
4. **Data Structures**: Arrays, objects, basic collections
5. **File I/O**: Reading/writing files, working with text
6. **Basic Algorithms**: Loops, searching, basic sorting

### Intermediate Phase (3-6 months)
1. **OOP**: Classes, objects, inheritance, polymorphism
2. **Advanced Data Structures**: Linked lists, stacks, queues, trees, graphs
3. **Algorithm Analysis**: Complexity, optimization, trade-offs
4. **Problem-Solving**: LeetCode, algorithm challenges
5. **Design Patterns**: Common patterns and their applications
6. **Error Handling**: Exceptions, logging, debugging

### Advanced Phase (6-12+ months)
1. **Advanced Algorithms**: Graph algorithms, dynamic programming
2. **System Design**: Architecture, scalability, databases
3. **CS Theory**: Compilers, networks, distributed systems
4. **Functional Programming**: Functional concepts and patterns
5. **Performance**: Profiling, optimization, memory management
6. **Advanced Language Features**: Metaprogramming, reflection, macros
7. **Additional Languages**: Learn second/third language efficiently

## Recommended Projects

### Beginner
- Calculator with basic operations
- Todo list application
- File processor (line counter, search)
- Simple game (tic-tac-toe, snake)
- Data analysis script

### Intermediate
- Web API with database
- Chat application with sockets
- Data structure implementation (linked list, tree)
- Algorithm implementation with benchmarks
- CLI tool with argument parsing
- Game with graphics (Pygame, Three.js)

### Advanced
- Search engine or crawler
- Database system implementation
- Distributed system design
- Compiler or interpreter
- System tool (similar to Unix utilities)
- Complex algorithm visualization

## Tools & Technologies

**Languages**: Python, JavaScript, Go, Rust, Java, C++, Ruby, PHP
**IDEs**: VS Code, IntelliJ IDEA, PyCharm, CLion, Sublime Text
**Compilers/Interpreters**: Python, Node.js, Go, Rust, Java, GCC
**Version Control**: Git, GitHub, GitLab
**Testing**: Pytest, Jest, Go testing, Catch2, JUnit
**Build Tools**: Maven, Gradle, Cargo, Make, CMake
**Package Managers**: Pip, NPM, Cargo, Maven, Composer
**Debugging**: GDB, LLDB, IDE debuggers, profiling tools
**Documentation**: Doxygen, JavaDoc, docstrings, Sphinx

## Career Progression

| Role | Experience | Salary (USD) | Focus |
|------|-----------|-------------|-------|
| Junior Dev | 0-2 years | $50K-$80K | Fundamentals, basics |
| Software Eng | 2-5 years | $90K-$140K | Design, architecture |
| Senior Eng | 5+ years | $140K-$200K | Leadership, innovation |
| Staff Eng | 7+ years | $180K-$300K | Strategy, systems |

## Quick Start

1. Choose one language (Python or JavaScript recommended)
2. Learn fundamentals through interactive platforms
3. Practice basic algorithms and data structures
4. Implement data structures from scratch
5. Solve algorithm problems (LeetCode, HackerRank)
6. Learn design patterns and principles
7. Build projects combining multiple concepts
8. Learn additional languages from your foundation

## Resources

**Learn**: FreeCodeCamp, Codecademy, Educative, Coursera, MIT OpenCourseWare
**Practice**: LeetCode, HackerRank, Codeforces, CodeWars, Kattis
**Theory**: "Introduction to Algorithms" (CLRS), "Computer Science Distilled"
**Visualization**: Visualgo, Sorting Visualizers, Animated Algorithms
**Community**: Stack Overflow, Dev.to, Medium, GitHub

---

Ready to master fundamentals? Invoke the `programming-languages` skill for language-specific guides.
